유니온 파인드란?(union-find)
원소들을 그룹으로 관리하는 (트리형)자료구조인데, 상호 배타적인 집합을 표현한다. 즉, 각각의 집합은 서로 중복된 원소를 가지지 않고
각 집합은 로트노드를 가지고 있다. 이 루트 노드를 활용해서 같은 집합에 속하는지 판별한다.
여러 노드가 존재 할 때, 두 개의 노드를 선택해서 서로 같은 집합에 속하는지 판별하는 알고리즘이다.

union : 2개 원소로 이루어진 집합을 하나의 집합으로 합친다. 이 때 보통 값이 작은 노드가 부모 노드가 된다.
find : 특정 원소가 속한 집합이 뭔지 알려주는 연산.

find알고리즘은 union연산이 편향되게 이루어지는 경우 비효율적으로 동작한다.
최악의 경우 Find함수는 모든 노드를 다 확인하게 되어 시간 복잡도가 O(n)이 된다. (n은 노드의 개수)
이러한 문제를 "경로 압축"을 통해서 해결한다.
find함수를 재귀적으로 호출한 뒤, parent 값을 find 함수의 결과로 갱신한다.

<편향된 상태>                                              <경로 압축>
  1                                                              1
    \                                                   /      /        \     \
      2                                                2       3         4      5
        \                               =>    
          3
            \
              4
                \
                  5


위와 같은 상황에서 find(5)를 수행하면 5부터 1까지의 경로가 일직선이라 많은 횟수의 재귀함수 호출이 일어난다. 최악의 경우 시간 복잡도는 O(N)
그런데, 만약 한 번 5의 루트가 1인 걸 알았다면, 왜 다음 번에 다시 그걸 구해야할까? 그냥 5를 바로 1아래에 이어버리면 어떨까?
또, 이것을 경로압축이라고 한다.


크기가 N인 유니온 파인드 구조에 M번 find 연산을 수행했을 때 최악의 시간복잡도는 O(MN)이다. 정말 운이 없어서 N개 원소가 다 일렬로 늘어서있을 때지만, 그래도 가능성이 0은 아니다.

그러나 이렇게 매번 루트를 갱신해버렸을 때는 시간이 무지하게 빨라지게 되는데, 여기다 union 연산을 특수하게 구현한다면 amortized(순간순간은 해당 시간을 초과할 수 있지만, 전체적으로 보았을 때는 평균이 이렇게 회귀함) O(Mlog*N)이라는 좀 기괴한 시간복잡도가 되는데,
저 로그스타라는 함수는 아크만 함수(Ackman function)의 역함수로 미칠듯이 느리게 증가해서 겨우 5가 되는 데에도 2^65536이 필요
해당 함수에 대한 건 위키에 나와 있으므로 링크(https://en.wikipedia.org/wiki/Ackermann_function)

여튼 저따위로 느리게 증가해서 평소엔 그냥 1~2라고 봐도 좋고, 왠만해서는 거의 선형 시간과 동급으로 취급된다. 즉 O(M).


   

